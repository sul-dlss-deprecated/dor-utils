#!/usr/bin/env ruby
USAGE = 'Usage: nohup fix-derivatives [-e ENVIRONMENT] druid >& /dev/null &'
require_relative '../config/boot'
require 'pathname'
require 'assembly-image'

class ShelvingFixer
  def initialize(druid, logger)
    @druid = druid
    @item = Dor::Item.find @druid
    @stacks_druid = DruidTools::StacksDruid.new @druid, Dor::Config.stacks.local_stacks_root
    @workspace_druid = DruidTools::Druid.new @druid, Dor::Config.stacks.local_workspace_root
    @tmp_path = Pathname.new "/imtmp/shelve_fix/#{@stacks_druid.id}"
    @logger = logger
  end

  def fix
    unless @item.current_version.to_i == 1
      @logger.error "Object #{@druid} current version does not equal 1, it is: #{@item.current_version}"
      return
    end
    @logger.info "Fixing #{@druid}"
    cm = @item.contentMetadata.ng_xml
    cm.xpath('//resource[@type="image"]').each do |resource|
      display_img = resource.at_xpath "file[@shelve='yes']"
      if display_img.nil?
        @logger.error "No shelvable image for object #{@druid}, resource sequence# #{resource['sequence']}"
        next
      end
      next unless @stacks_druid.find_content(display_img['id']).nil?
      @logger.info "     Restoring jp2 #{display_img['id']}"
      jp2_path = @workspace_druid.find_content display_img['id']

      if jp2_path
        @item.clear_diff_cache  # derivative still in workspace.  Clear out the diff cache
      else
        master_img = resource.at_xpath "file[@preserve='yes']"
        if master_img.nil?
          @logger.error "No preserved image for #{@druid}, resource sequence# #{resource['sequence']}"
          next
        end

        tmp_src_img = fetch_file_from_sdr master_img['id']
        jp2_path = create_jp2 tmp_src_img, display_img['id']
      end

      FileUtils.cp jp2_path, @stacks_druid.content_dir
    end
    @logger.info '------------------'
  end

  # Gets preservation file from sdr
  # @return [String] local path to preservation file
  def fetch_file_from_sdr(file_name)
    @tmp_path.mkpath
    res = @item.get_preserved_file file_name, '1'
    unless res.is_a? Net::HTTPSuccess
      fail "Problem fetching file '#{file_name}' from SDR #{res.code}: #{res.message}"
    end
    src_img = @tmp_path.join(file_name).to_s
    File.open(src_img, 'wb') do |f|
      f.write res.body
    end
    src_img
  end

  # Creates jp2 display derivative
  # @return [String] local path to jp2 display derivative
  def create_jp2(src_img, new_jp2_name)
    ai = Assembly::Image.new(src_img)
    tmp_jp2_path = @tmp_path.join(new_jp2_name).to_s
    ai.create_jp2 output: tmp_jp2_path
    tmp_jp2_path
  end
end

class BatchFixer
  def initialize
    @log = Logger.new File.expand_path(File.dirname(__FILE__) + '/../log/fix-derivatives.log')
    @log.datetime_format = '%m-%e-%y %H:%M'
    @log.formatter = proc { |severity, datetime, _progname, msg|
      "#{severity} #{datetime}: #{msg}\n"
    }
  end

  def fix(args)
    druids = IO.readlines(args.first).map(&:strip)

    druids.each do |druid|
      begin
        next if druid.empty?
        ShelvingFixer.new(druid, @log).fix
      rescue => e
        @log.error "Problem with #{druid} - #{e.inspect}"
        @log.error e.backtrace.join "\n"
      end
    end
  end
end

BatchFixer.new.fix ARGV
