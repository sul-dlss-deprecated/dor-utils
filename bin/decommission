#!/usr/bin/env ruby
USAGE = "Usage: decomission [-e ENVIRONMENT] druid:aa123bb4567|druids.txt \"Decomission tag\""
require_relative '../config/boot'

class Decom
  def initialize
    log = File.expand_path(File.dirname(__FILE__) + '/../log/decommission.log')
    @logger = Logger.new log
    @logger.formatter = proc { |severity, datetime, _progname, msg|
      "#{severity} #{datetime}[#{Process.pid}]: #{msg}\n"
    }
  end

  def start(args)
    if (args.size != 2)
      puts USAGE
      exit
    end
    druid_arg = args.shift
    if DruidTools::Druid.valid? druid_arg
      @druids = [druid_arg]
    else
      lines = IO.readlines(druid_arg).map(&:strip)
      lines.pop if lines.last.empty?
      @druids = lines.map do |id|
        if id =~ /^druid:/
          id
        else
          "druid:#{id}"
        end
      end
    end
    @tag = args.shift

    decomission
  end

  def decomission
    @druids.each do |druid|
      begin
        obj = Dor::Item.find druid
        obj.decomission @tag
        obj.save

        Dor::DigitalStacksService.prune_stacks_dir druid
        obj.publish_metadata
        Dor::CleanupService.cleanup_by_druid druid
        Dor::WorkflowService.archive_active_workflow 'dor', druid
        @logger.info "Decomissioned #{druid}"
      rescue => e
        @logger.error "Unable to decomission #{druid} : #{e.inspect}"
        @logger.error e.backtrace.join("\n")
        Honeybadger.notify(e)
      end
    end
  end
end

Decom.new.start ARGV
